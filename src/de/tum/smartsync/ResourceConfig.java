// SmartSync is an Android Framework for Smart Mobile Synchronization
// Copyright (C) 2013 Daniel Hugenroth
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
package de.tum.smartsync;

import java.nio.ByteBuffer;

import de.tum.smartsync.helper.TimeProvider;
import de.tum.smartsync.resource.ResourceBundle;

/**
 * <p>
 * Instances of this class describe characteristics and requirements for
 * individual resources. They are referenced by the {@link Resource} class and
 * stored by SyncManagers if necessary.
 * 
 * <p>
 * In order to apply a ResourceConfig to several resources at once, you should
 * use the {@link ResourceBundle} class.
 * 
 * @author Daniel
 * 
 */
public class ResourceConfig {

	private static final long DEFAULT_CACHE_LIFESPAN = 3 * TimeProvider.DAY;

	private static final long DEFAULT_UPDATE_INTERVAL = 12 * TimeProvider.HOUR;

	private static final int DEFAULT_PRIORITY = 0;

	private static final boolean DEFAULT_CONNECTION_DECISION = true;

	/**
	 * The time in ms before the data in the cache expires.
	 */
	protected long mCacheLifespan = DEFAULT_CACHE_LIFESPAN;

	/**
	 * The time in ms after the data is old enough for an update
	 */
	protected long mUpdateInterval = DEFAULT_UPDATE_INTERVAL;

	/**
	 * Should we request different resources based on our current connection?
	 */
	protected boolean mConnectionDecisive = DEFAULT_CONNECTION_DECISION;

	/**
	 * Used by synchronizing algorithms to determine order and urgency
	 */
	protected int mPriority = DEFAULT_PRIORITY;

	/**
	 * Used to determine the structure of the marshalled data
	 */
	private static final int CLASS_VERSION = 0x01;

	// 4 variables of max 64bit each
	public static final int MARSHALL_SIZE = 4 * 8;

	/**
	 * Default constructor creates a new ResourceConfig with default values.
	 */
	public ResourceConfig() {
		// default values are set above
	}

	/**
	 * Creates a new ResourceConfig using the bytes got by the
	 * <code>marshall()</code> method.
	 * 
	 * @param raw
	 *            Byte generated by a marshall method
	 * @throws RuntimeException
	 *             If the <code>raw</code> array could not be parsed.
	 */
	public ResourceConfig(byte[] raw) {
		this.unmarshall(raw);
	}

	/**
	 * Writes all internal information into a byte array for permanent storage.
	 * 
	 * @return a byte array of <code>MARSHALL_SIZE</code> length.
	 */
	public byte[] marshall() {
		// We use this manual written serialization method instead of a more
		// sophisticated solution (like XML, Serializable or similar) due to
		// performance reasons.
		ByteBuffer bb = ByteBuffer.wrap(new byte[MARSHALL_SIZE]);

		bb.putInt(CLASS_VERSION);
		bb.putLong(mCacheLifespan);
		bb.putLong(mUpdateInterval);
		bb.putInt(mConnectionDecisive ? 1 : 0);
		bb.putInt(mPriority);

		return bb.array();
	}

	/**
	 * Overrides the current values of this resource value using the data from
	 * the provided marshalled configuration
	 * 
	 * @param raw
	 *            Byte array created using the <code>marshall</code> method
	 */
	public void unmarshall(byte[] raw) {
		ByteBuffer bb = ByteBuffer.wrap(raw);
		int version = bb.getInt();

		switch (version) {
		case 0x01:
			this.mCacheLifespan = bb.getLong();
			this.mUpdateInterval = bb.getLong();
			this.mConnectionDecisive = bb.getInt() == 1 ? true : false;
			this.mPriority = bb.getInt();
			break;

		default:
			throw new RuntimeException("Unknown resource config class version!");
		}
	}

	// GETTER & SETTER

	public long getCacheLifespan() {
		return mCacheLifespan;
	}

	public void setCacheLifespan(long cacheLifespan) {
		this.mCacheLifespan = cacheLifespan;
	}

	public long getUpdateInterval() {
		return mUpdateInterval;
	}

	public void setUpdateInterval(long updateInterval) {
		this.mUpdateInterval = updateInterval;
	}

	public boolean isConnectionDecisive() {
		return mConnectionDecisive;
	}

	public void setConnectionDecisive(boolean connectionDecisive) {
		this.mConnectionDecisive = connectionDecisive;
	}

	public int getPriority() {
		return mPriority;
	}

	public void setPriority(int priority) {
		this.mPriority = priority;
	}

}
